<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K14: Ice Jelly Sumo</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; width: 100vw; height: 100vh;
            overflow: hidden; font-family: 'Arial Black', sans-serif;
            background-color: #051320; touch-action: none; user-select: none;
            display: flex; justify-content: center; align-items: center;
        }

        #game-container {
            width: 100%; max-width: 480px; height: 100%; max-height: 900px;
            position: relative; background-color: #0a192f; overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* 화면 분할 가이드 */
        #guide-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; pointer-events: none; z-index: 5;
        }
        .guide-side {
            flex: 1; display: flex; justify-content: center; align-items: flex-start; padding-top: 20px;
            font-size: 2.5rem; color: rgba(255,255,255,0.3); font-weight: 900;
            text-transform: uppercase; text-align: center; text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .guide-side:first-child { 
            border-bottom: 4px dashed rgba(255,255,255,0.2); 
            transform: rotate(180deg); /* 마주보는 사람을 위해 글자 뒤집기 */
        }
        #guide-p2 { align-items: flex-end; padding-top: 0; padding-bottom: 20px; }

        /* 오버레이 UI */
        #overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 10, 20, 0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10;
        }
        #overlay h1 { color: #81d4fa; font-size: 3.5rem; margin-bottom: 10px; text-align: center; text-shadow: 0 0 20px #00ffff; }
        #win-text { font-size: 3rem; margin-bottom: 30px; text-shadow: 0 5px 10px rgba(0,0,0,0.5); animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes pop { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        #start-btn {
            padding: 15px 50px; font-size: 1.5rem; font-weight: bold; background: #fff;
            color: #000; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 6px 0 #81d4fa; transition: 0.1s;
        }
        #start-btn:active { transform: translateY(6px); box-shadow: none; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="guide-layer">
            <div class="guide-side" id="guide-p1">TAP TO DASH<br>(RED)</div>
            <div class="guide-side" id="guide-p2">TAP TO DASH<br>(BLUE)</div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="overlay">
            <h1 id="title-text">ICE JELLY<br>SUMO</h1>
            <div id="win-text" style="display: none;"></div>
            <button id="start-btn">FIGHT!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        const titleText = document.getElementById('title-text');
        const winText = document.getElementById('win-text');
        const guideLayer = document.getElementById('guide-layer');
        const gameContainer = document.getElementById('game-container');

        let width, height;
        let isPlaying = false;

        // 탑다운 물리 엔진 상수 (얼음판)
        const FRICTION = 0.96; // 마찰력이 매우 적어 미끄러짐
        const DASH_FORCE = 15; // 탭할 때의 돌진력
        const BOUNCE_FORCE = 12; // 부딪혔을 때 튕겨나가는 힘

        let snowflakes = [];
        let ring = { x: 0, y: 0, radius: 0 }; // 원형 경기장

        // 오디오 시스템
        let audioCtx;
        function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if(audioCtx.state === 'suspended') audioCtx.resume(); }
        function playSound(type) {
            if(!audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            if(type === 'dash') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if(type === 'squish') { // 젤리끼리 충돌
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if(type === 'fall') { // 장외 탈락
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0, now + 0.8);
                osc.start(now); osc.stop(now + 0.8);
            }
        }

        class Jelly {
            constructor(x, y, color, isP1) {
                this.x = x; this.y = y;
                this.vx = 0; this.vy = 0;
                this.radius = 35; 
                this.color = color;
                this.isP1 = isP1; 
                this.scale = 1; // 추락 시 작아지는 효과용
                this.isDead = false;
            }

            dash() {
                if(!isPlaying || this.isDead) return;
                
                // P1(위쪽)은 아래로(+y), P2(아래쪽)는 위로(-y) 대시
                let dirY = this.isP1 ? 1 : -1;
                
                // 돌진력 추가 (약간의 랜덤 X값으로 궤적을 예측 불가능하게 만듦)
                this.vy += DASH_FORCE * dirY;
                this.vx += (Math.random() - 0.5) * 6; 

                playSound('dash');
            }

            update(ring) {
                if(this.isDead) {
                    // 죽으면 (장외로 떨어지면) 점점 작아짐
                    this.scale = Math.max(0, this.scale - 0.05);
                    return;
                }

                // 이동 및 마찰력 적용
                this.x += this.vx; this.y += this.vy;
                this.vx *= FRICTION; this.vy *= FRICTION;

                // 장외 판정 (원형 경기장 중심과의 거리가 반지름보다 멀어지면 탈락)
                let distToCenter = Math.hypot(this.x - ring.x, this.y - ring.y);
                if (distToCenter > ring.radius) {
                    this.isDead = true;
                    playSound('fall');
                }
            }

            draw() {
                if (this.scale <= 0) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // 이동 방향에 맞춰 회전
                let speed = Math.hypot(this.vx, this.vy);
                if (speed > 0.1) {
                    ctx.rotate(Math.atan2(this.vy, this.vx));
                } else {
                    // 가만히 있을 때는 상대방 쪽을 바라봄
                    ctx.rotate(this.isP1 ? Math.PI/2 : -Math.PI/2);
                }

                // 속도에 따른 찌그러짐 (스쿼시 앤 스트레치)
                // 현재 회전된 좌표계에서 x축이 전진 방향
                let stretch = 1 + speed * 0.02;
                let squash = 1 / stretch;
                ctx.scale(stretch * this.scale, squash * this.scale);

                // 그림자
                ctx.beginPath(); ctx.arc(-5, 5, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fill();

                // 몸통
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
                
                // 탑다운 입체감(하이라이트)
                ctx.beginPath(); ctx.arc(0, 0, this.radius - 2, 0, Math.PI * 2);
                let grad = ctx.createRadialGradient(-10, -10, 5, 0, 0, this.radius);
                grad.addColorStop(0, 'rgba(255,255,255,0.7)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad; ctx.fill();

                // 눈 (진행 방향인 +x 축을 향해 배치)
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(15, -12, 7, 0, Math.PI*2); ctx.fill(); // 왼쪽 눈
                ctx.beginPath(); ctx.arc(15, 12, 7, 0, Math.PI*2); ctx.fill(); // 오른쪽 눈
                
                // 눈동자
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(18, -12, 3, 0, Math.PI*2); ctx.fill(); 
                ctx.beginPath(); ctx.arc(18, 12, 3, 0, Math.PI*2); ctx.fill();

                ctx.restore();
            }
        }

        let p1, p2;

        function initSnow() {
            snowflakes = [];
            for(let i=0; i<50; i++) {
                snowflakes.push({ x: Math.random()*width, y: Math.random()*height, size: Math.random()*2 + 1, speedX: (Math.random()-0.5)*1, speedY: Math.random()*2 + 1 });
            }
        }

        function resize() {
            width = gameContainer.clientWidth; 
            height = gameContainer.clientHeight;
            canvas.width = width; canvas.height = height;
            
            // 원형 경기장 중앙 배치
            ring.x = width / 2;
            ring.y = height / 2;
            ring.radius = width * 0.45; // 화면 너비의 90%를 꽉 채우는 원
            
            initSnow();
        }
        window.addEventListener('resize', resize);
        resize();

        // 입력 처리 (화면 상/하 분할)
        function handleInput(e) {
            if(!isPlaying) return;
            e.preventDefault();
            
            let rect = canvas.getBoundingClientRect();
            // 여러 손가락 터치 지원
            let touches = e.touches ? e.touches : [{ clientY: e.clientY }];
            
            for(let i=0; i<touches.length; i++) {
                let yPos = touches[i].clientY - rect.top;
                if(yPos < height / 2) p1.dash(); // 위쪽 절반 누르면 P1 돌진
                else p2.dash(); // 아래쪽 절반 누르면 P2 돌진
            }
        }
        
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, {passive: false});

        function resolveCollision(j1, j2) {
            if (j1.isDead || j2.isDead) return;

            let dx = j2.x - j1.x; let dy = j2.y - j1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = j1.radius + j2.radius;

            if (dist < minDist) {
                let angle = Math.atan2(dy, dx);
                let overlap = minDist - dist;
                
                // 겹친 만큼 밀어내기
                j1.x -= Math.cos(angle) * (overlap / 2); j1.y -= Math.sin(angle) * (overlap / 2);
                j2.x += Math.cos(angle) * (overlap / 2); j2.y += Math.sin(angle) * (overlap / 2);

                // 탄성 충돌 (튕겨내기)
                j1.vx -= Math.cos(angle) * BOUNCE_FORCE; j1.vy -= Math.sin(angle) * BOUNCE_FORCE;
                j2.vx += Math.cos(angle) * BOUNCE_FORCE; j2.vy += Math.sin(angle) * BOUNCE_FORCE;
                
                playSound('squish');
                if(navigator.vibrate) navigator.vibrate(30);
            }
        }

        function gameOver(winnerName, color) {
            isPlaying = false;
            guideLayer.style.display = 'flex';
            if(navigator.vibrate) navigator.vibrate(300);

            setTimeout(() => {
                overlay.style.display = 'flex';
                titleText.style.display = 'none';
                winText.style.display = 'block';
                
                // 승자가 마주보는 사람(P1-RED)일 수 있으므로 글자를 뒤집어서 보여줌
                if(winnerName === "RED") winText.style.transform = "rotate(180deg) scale(1)";
                else winText.style.transform = "rotate(0deg) scale(1)";
                
                winText.innerText = `${winnerName} WINS!`;
                winText.style.color = color;
                startBtn.innerText = 'REMATCH';
            }, 1000); // 떨어지는 애니메이션을 볼 수 있게 1초 대기
        }

        function update() {
            if(!isPlaying) return;

            p1.update(ring); p2.update(ring);
            resolveCollision(p1, p2);

            // 승패 판정
            if (p1.isDead && p2.isDead) gameOver("DRAW", "#fff");
            else if (p1.isDead) gameOver("BLUE", "#3498db");
            else if (p2.isDead) gameOver("RED", "#e74c3c");

            // 눈 파티클 이동
            snowflakes.forEach(s => {
                s.x += s.speedX; s.y += s.speedY;
                if(s.y > height) { s.y = -10; s.x = Math.random() * width; }
                if(s.x > width || s.x < 0) s.speedX *= -1;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 눈 파티클 (배경)
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            snowflakes.forEach(s => { ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });

            // 탑다운 얼음 경기장 렌더링
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI*2);
            ctx.fillStyle = '#1c3d5a'; // 깊은 얼음 색
            ctx.fill();
            
            // 얼음판 빛 반사 효과
            let iceGrad = ctx.createLinearGradient(ring.x - ring.radius, ring.y - ring.radius, ring.x + ring.radius, ring.y + ring.radius);
            iceGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            iceGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.0)');
            iceGrad.addColorStop(1, 'rgba(129, 212, 250, 0.2)');
            ctx.fillStyle = iceGrad;
            ctx.beginPath(); ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI*2); ctx.fill();

            // 경기장 외곽선 (벽면)
            ctx.lineWidth = 6; ctx.strokeStyle = '#81d4fa';
            ctx.beginPath(); ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI*2); ctx.stroke();
            
            // 중앙선 장식
            ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(129, 212, 250, 0.3)';
            ctx.beginPath(); ctx.moveTo(ring.x - ring.radius, ring.y); ctx.lineTo(ring.x + ring.radius, ring.y); ctx.stroke();
            ctx.beginPath(); ctx.arc(ring.x, ring.y, 40, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = 'rgba(129, 212, 250, 0.5)'; ctx.beginPath(); ctx.arc(ring.x, ring.y, 8, 0, Math.PI*2); ctx.fill();

            if(p1 && p2) { p1.draw(); p2.draw(); }
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }

        startBtn.addEventListener('click', () => {
            initAudio(); isPlaying = true;
            guideLayer.style.display = 'none'; overlay.style.display = 'none';
            
            // 젤리 초기화 (경기장 위/아래 가장자리 부근)
            p1 = new Jelly(ring.x, ring.y - ring.radius + 60, '#e74c3c', true);
            p2 = new Jelly(ring.x, ring.y + ring.radius - 60, '#3498db', false);
        });

        // 초기 화면 렌더링용
        p1 = new Jelly(ring.x, ring.y - ring.radius + 60, '#e74c3c', true);
        p2 = new Jelly(ring.x, ring.y + ring.radius - 60, '#3498db', false);
        draw(); loop();

    </script>
</body>
</html>