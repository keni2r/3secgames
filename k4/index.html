<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>8-bit Coin Drop: Balanced</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0f380f; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
        }
        canvas { 
            display: block; 
            background: #9bbc0f; 
            margin: auto;
            border: 4px solid #306230;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(155, 188, 15, 0.5);
        }
        #uiLayer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #0f380f;
            text-align: center;
            pointer-events: none; 
        }
        h1 { font-size: 24px; line-height: 1.5; margin-bottom: 20px; text-shadow: 2px 2px #8bac0f; }
        p { font-size: 14px; line-height: 1.5; margin-bottom: 20px; }
        
        .btn {
            pointer-events: auto;
            background: #0f380f;
            color: #9bbc0f;
            border: 4px solid #306230;
            padding: 15px 20px;
            margin: 10px;
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); background: #306230; }
        #gameOverUI, #successUI { display: none; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="uiLayer">
        <div id="startUI">
            <h1>COIN<br>DROP</h1>
            <p>- TAP TO START -</p>
        </div>
        <div id="gameOverUI">
            <h1>GAMEOVER!</h1>
            <p id="finalScoreText">FAILED AT LV 1</p>
            <button class="btn" onclick="restartGame()">RETRY</button>
        </div>
        <div id="successUI">
            <h1>CLEAR!</h1>
            <p>YOU BEAT STAGE 4!</p>
            <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startUI = document.getElementById('startUI');
    const gameOverUI = document.getElementById('gameOverUI');
    const successUI = document.getElementById('successUI');
    const finalScoreText = document.getElementById('finalScoreText');

    canvas.width = 400; 
    canvas.height = 600;

    const C_DARK = '#0f380f';
    const C_MID_DARK = '#306230';
    const C_MID_LIGHT = '#8bac0f';
    const C_LIGHT = '#9bbc0f';

    const pixelSize = 4;

    const coinSprite = [
        [0,0,2,2,2,2,0,0],
        [0,2,1,3,3,1,2,0],
        [2,1,3,1,1,3,1,2],
        [2,3,1,3,3,1,3,2],
        [2,3,1,3,3,1,3,2],
        [2,1,3,1,1,3,1,2],
        [0,2,1,3,3,1,2,0],
        [0,0,2,2,2,2,0,0]
    ];

    const pegSprite = [
        [0,2,2,0],
        [2,1,3,2],
        [2,1,1,2],
        [0,2,2,0]
    ];

    let state = 'START'; 
    let level = 1; 
    
    let coin = { x: 200, y: 50, vx: 0, vy: 0, r: 16 };
    let pegs = [];
    let basket = { x: 0, y: canvas.height - 40, w: 256, h: 40, vx: 0 }; 

    function createBoard() {
        pegs = [];
        const rows = 6;
        const startY = 130;
        const gapY = 60;
        const gapX = 65;

        for (let r = 0; r < rows; r++) {
            let cols = (r % 2 === 0) ? 6 : 5;
            let startX = (r % 2 === 0) ? 37.5 : 70;

            for (let c = 0; c < cols; c++) {
                pegs.push({
                    x: startX + c * gapX,
                    y: startY + r * gapY,
                    r: 6, 
                    isBumper: false
                });
            }
        }

        let shuffledPegs = [...pegs].sort(() => 0.5 - Math.random());
        for (let i = 0; i < 3; i++) { 
            if (shuffledPegs[i]) {
                shuffledPegs[i].isBumper = true;
                shuffledPegs[i].r = 12; 
            }
        }
    }

    function initRound() {
        coin.y = 50;
        coin.vy = 0;
        coin.vx = 0;
        
        if (level === 1) {
            basket.w = 256; 
            basket.vx = 0;
        } else if (level === 2) {
            basket.w = 128; 
            basket.vx = 0;
        } else if (level === 3) {
            basket.w = 96;  // 너무 좁았던 크기를 64에서 96으로 넓힘
            basket.vx = 0;
        } else if (level === 4) {
            basket.w = 96;  // 4단계 크기도 96으로 통일
            basket.vx = 1.8; 
        }

        let maxPos = canvas.width - basket.w;
        basket.x = Math.random() * maxPos;
        
        state = 'AIMING';
    }

    function drawSprite(sprite, x, y, scale = pixelSize) {
        let width = sprite[0].length * scale;
        let height = sprite.length * scale;
        let startX = x - width / 2;
        let startY = y - height / 2;

        for (let r = 0; r < sprite.length; r++) {
            for (let c = 0; c < sprite[r].length; c++) {
                if (sprite[r][c] === 1) ctx.fillStyle = C_MID_DARK;
                else if (sprite[r][c] === 2) ctx.fillStyle = C_DARK;
                else if (sprite[r][c] === 3) ctx.fillStyle = C_MID_LIGHT;
                else continue;
                ctx.fillRect(startX + c * scale, startY + r * scale, scale, scale);
            }
        }
    }

    function drawBasket(b) {
        // 메인 몸통
        ctx.fillStyle = C_MID_DARK;
        ctx.fillRect(b.x, b.y, b.w, b.h);

        // 테두리
        ctx.fillStyle = C_DARK;
        ctx.fillRect(b.x, b.y, b.w, 4); 
        ctx.fillRect(b.x, b.y, 4, b.h); 
        ctx.fillRect(b.x + b.w - 4, b.y, 4, b.h); 
        ctx.fillRect(b.x, b.y + b.h - 4, b.w, 4); 

        // 8비트 하이라이트 디테일
        ctx.fillStyle = C_MID_LIGHT;
        ctx.fillRect(b.x + 4, b.y + 4, 4, b.h - 8); 
        ctx.fillRect(b.x + 8, b.y + 4, b.w - 12, 4); 
        
        // SAFE 텍스트 렌더링 코드 제거 완료
    }

    function update() {
        if (state !== 'DROPPING') return;

        if (level === 4) {
            basket.x += basket.vx;
            if (basket.x < 0) {
                basket.x = 0;
                basket.vx *= -1;
            } else if (basket.x + basket.w > canvas.width) {
                basket.x = canvas.width - basket.w;
                basket.vx *= -1;
            }
        }

        coin.vy += 0.3;
        if (coin.vy > 8) coin.vy = 8; 

        coin.x += coin.vx;
        coin.y += coin.vy;

        if (coin.x - coin.r < 0) {
            coin.x = coin.r;
            coin.vx *= -0.6; 
        } else if (coin.x + coin.r > canvas.width) {
            coin.x = canvas.width - coin.r;
            coin.vx *= -0.6;
        }

        pegs.forEach(peg => {
            let dx = coin.x - peg.x;
            let dy = coin.y - peg.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDist = coin.r + peg.r;

            if (distance < minDist) {
                let overlap = minDist - distance;
                let nx = dx / distance;
                let ny = dy / distance;
                coin.x += nx * overlap;
                coin.y += ny * overlap;

                let dotProduct = (coin.vx * nx + coin.vy * ny);
                
                let bounce = peg.isBumper ? 1.3 : 0.55; 
                coin.vx = (coin.vx - 2 * dotProduct * nx) * bounce;
                coin.vy = (coin.vy - 2 * dotProduct * ny) * bounce;

                coin.vx += (Math.random() - 0.5) * (peg.isBumper ? 4.0 : 1.5);
                
                if (Math.abs(coin.vx) < 0.5) {
                    coin.vx += (Math.random() > 0.5 ? 1 : -1) * 2;
                }
            }
        });

        if (coin.y + coin.r > basket.y) {
            if (coin.x > basket.x && coin.x < basket.x + basket.w) {
                level++;
                if (level > 4) {
                    state = 'GAMECLEAR';
                    successUI.style.display = 'block';
                } else {
                    createBoard(); 
                    initRound(); 
                }
            } else {
                state = 'GAMEOVER';
                finalScoreText.innerText = `FAILED AT LV ${level}`;
                level = 1;
                gameOverUI.style.display = 'block';
            }
        }
    }

    function draw() {
        ctx.fillStyle = C_LIGHT;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (state === 'START') return;

        if (state === 'AIMING') {
            ctx.fillStyle = C_MID_LIGHT;
            ctx.fillRect(0, 40, canvas.width, 2);
            ctx.font = "10px 'Press Start 2P', cursive";
            ctx.fillStyle = C_MID_DARK;
            ctx.fillText("TAP TO DROP!", canvas.width / 2 - 50, 30);
        }

        drawBasket(basket);

        pegs.forEach(peg => {
            let scale = peg.isBumper ? 5 : 3; 
            drawSprite(pegSprite, peg.x, peg.y, scale);
        });

        drawSprite(coinSprite, coin.x, coin.y);

        ctx.fillStyle = C_DARK;
        ctx.font = "14px 'Press Start 2P', cursive";
        
        let levelText = level;
        if(level === 1) levelText = "1(LARGE)";
        if(level === 2) levelText = "2(MED)";
        if(level === 3) levelText = "3(SMALL)";
        if(level === 4) levelText = "4(MOVE)";
        
        ctx.fillText(`LVL:${levelText}`, 15, 30);
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function handleInput(e, type) {
        e.preventDefault();
        
        if (state === 'START') {
            state = 'AIMING';
            startUI.style.display = 'none';
            createBoard();
            initRound();
            return;
        }

        let rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let scaleX = canvas.width / rect.width;
        let x = (clientX - rect.left) * scaleX;

        if (state === 'AIMING') {
            if (type === 'move' || type === 'down') {
                coin.x = Math.max(coin.r, Math.min(x, canvas.width - coin.r));
            }
            if (type === 'up') {
                state = 'DROPPING';
                coin.vx = (Math.random() - 0.5) * 1.0; 
            }
        }
    }

    window.restartGame = function() {
        level = 1;
        gameOverUI.style.display = 'none';
        successUI.style.display = 'none';
        createBoard();
        initRound();
    };

    canvas.addEventListener('mousedown', (e) => handleInput(e, 'down'));
    canvas.addEventListener('mousemove', (e) => {
        if (e.buttons > 0) handleInput(e, 'move');
    });
    canvas.addEventListener('mouseup', (e) => handleInput(e, 'up'));

    canvas.addEventListener('touchstart', (e) => handleInput(e, 'down'), {passive: false});
    canvas.addEventListener('touchmove', (e) => handleInput(e, 'move'), {passive: false});
    canvas.addEventListener('touchend', (e) => handleInput(e, 'up'), {passive: false});

    document.fonts.ready.then(() => {
        loop();
    });

</script>
</body>
</html>